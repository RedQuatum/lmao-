<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Шах и Мат</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            background: linear-gradient(135deg, #1a2a6c, #2c3e50);
            padding: 20px;
            overflow: hidden;
            position: relative;
        }
        
        body::before {
            content: "";
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: 
                radial-gradient(circle at 10% 20%, rgba(255,255,255,0.1) 0%, transparent 20%),
                radial-gradient(circle at 90% 80%, rgba(255,255,255,0.1) 0%, transparent 20%);
            pointer-events: none;
        }
        
        /* Интро стили */
        .intro {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(135deg, #1a2a6c, #2c3e50);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 1000;
            opacity: 1;
            transition: opacity 1.5s ease-in-out;
        }
        
        .intro.hidden {
            opacity: 0;
            pointer-events: none;
        }
        
        .intro-text {
            color: white;
            font-size: 2.5rem;
            text-align: center;
            margin-bottom: 20px;
            opacity: 0;
            transform: translateY(30px);
            animation: fadeInUp 1.5s ease-out forwards;
        }
        
        .joke-text {
            color: rgba(255, 0, 0, 0.5);
            font-size: 1.2rem;
            text-align: center;
            opacity: 0;
            transform: translateY(20px);
            animation: fadeInUp 1.5s ease-out 0.5s forwards;
        }
        
        .container {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 30px;
            width: 100%;
            max-width: 900px;
            opacity: 0;
            animation: fadeIn 1s ease-out 2.5s forwards;
        }
        
        .header {
            text-align: center;
            color: white;
            text-shadow: 0 2px 10px rgba(0,0,0,0.5);
        }
        
        .header h1 {
            font-size: 3.5rem;
            margin-bottom: 10px;
            background: linear-gradient(to right, #e6dada, #f8d5d5);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            letter-spacing: 3px;
        }
        
        .chess-board {
            border: 15px solid #5d4037;
            border-radius: 8px;
            box-shadow: 
                0 15px 35px rgba(0, 0, 0, 0.5),
                0 0 0 2px #8d6e63,
                0 0 0 5px #5d4037;
            background: #5d4037;
            position: relative;
            overflow: hidden;
        }
        
        .chess-board::before {
            content: "";
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(45deg, rgba(255,255,255,0.05) 25%, transparent 25%, transparent 50%, 
                         rgba(255,255,255,0.05) 50%, rgba(255,255,255,0.05) 75%, transparent 75%, transparent);
            background-size: 30px 30px;
            pointer-events: none;
        }
        
        table {
            border-collapse: collapse;
            background-color: #fff;
            position: relative;
        }
        
        td {
            width: 70px;
            height: 70px;
            text-align: center;
            vertical-align: middle;
            font-size: 50px;
            cursor: pointer;
            position: relative;
            transition: background-color 0.3s ease;
        }
        
        .white {
            background-color: #f0d9b5;
        }
        
        .black {
            background-color: #b58863;
        }
        
        .white-piece {
            color: #ffffff;
            text-shadow: 0 2px 5px rgba(0, 0, 0, 0.6);
            transition: transform 0.2s ease;
        }
        
        .black-piece {
            color: #2c3e50;
            text-shadow: 0 2px 3px rgba(255, 255, 255, 0.5);
            transition: transform 0.2s ease;
        }
        
        .selected {
            background-color: rgba(155, 199, 0, 0.7) !important;
        }
        
        .possible-move {
            position: relative;
        }
        
        .possible-move::after {
            content: "";
            position: absolute;
            top: 50%;
            left: 50%;
            width: 25px;
            height: 25px;
            background: rgba(100, 200, 100, 0.4);
            border-radius: 50%;
            transform: translate(-50%, -50%);
            animation: pulse 1.5s infinite;
        }
        
        .possible-capture {
            position: relative;
        }
        
        .possible-capture::before {
            content: "";
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            box-shadow: inset 0 0 0 3px rgba(200, 50, 50, 0.7);
            border-radius: 50%;
            animation: pulse-red 1.5s infinite;
        }
        
        .check {
            background-color: rgba(255, 50, 50, 0.5) !important;
        }
        
        .checkmate {
            background-color: rgba(255, 0, 0, 0.7) !important;
            animation: pulse-checkmate 1.5s infinite;
        }
        
        .notation {
            position: absolute;
            font-size: 12px;
            font-weight: bold;
            color: rgba(0, 0, 0, 0.6);
            z-index: 1;
        }
        
        .top-notation {
            top: 4px;
            right: 6px;
        }
        
        .bottom-notation {
            bottom: 4px;
            left: 6px;
        }
        
        .controls {
            display: flex;
            flex-direction: column;
            gap: 20px;
            background: rgba(30, 40, 80, 0.7);
            padding: 25px;
            border-radius: 15px;
            box-shadow: 0 10px 25px rgba(0, 0, 0, 0.4);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            max-width: 300px;
        }
        
        .status {
            background: rgba(0, 0, 0, 0.3);
            color: white;
            padding: 15px;
            border-radius: 10px;
            text-align: center;
            font-size: 1.2rem;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }
        
        .buttons {
            display: flex;
            flex-direction: column;
            gap: 15px;
        }
        
        button {
            background: linear-gradient(to bottom, #3498db, #2980b9);
            color: white;
            border: none;
            padding: 14px;
            border-radius: 8px;
            font-size: 1.1rem;
            cursor: pointer;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 10px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.2);
        }
        
        button:hover {
            transform: translateY(-3px);
            box-shadow: 0 6px 10px rgba(0, 0, 0, 0.3);
            background: linear-gradient(to bottom, #3da5e0, #2c8fcc);
        }
        
        button:active {
            transform: translateY(1px);
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
        }
        
        .moved-piece {
            position: absolute;
            z-index: 10;
            pointer-events: none;
            transition: transform 0.4s cubic-bezier(0.34, 1.56, 0.64, 1);
        }
        
        .game-over {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 999;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.5s ease;
        }
        
        .game-over.active {
            opacity: 1;
            pointer-events: all;
        }
        
        .game-over h2 {
            color: white;
            font-size: 4rem;
            margin-bottom: 20px;
            text-shadow: 0 0 10px rgba(255, 0, 0, 0.7);
        }
        
        .game-over p {
            color: white;
            font-size: 1.5rem;
            margin-bottom: 30px;
        }
        
        .game-over button {
            font-size: 1.3rem;
            padding: 15px 30px;
        }
        
        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }
        
        @keyframes fadeInUp {
            from { opacity: 0; transform: translateY(30px); }
            to { opacity: 1; transform: translateY(0); }
        }
        
        @keyframes pulse {
            0% { transform: translate(-50%, -50%) scale(0.8); opacity: 0.7; }
            50% { transform: translate(-50%, -50%) scale(1.1); opacity: 1; }
            100% { transform: translate(-50%, -50%) scale(0.8); opacity: 0.7; }
        }
        
        @keyframes pulse-red {
            0% { box-shadow: inset 0 0 0 3px rgba(200, 50, 50, 0.4); }
            50% { box-shadow: inset 0 0 0 6px rgba(200, 50, 50, 0.8); }
            100% { box-shadow: inset 0 0 0 3px rgba(200, 50, 50, 0.4); }
        }
        
        @keyframes pulse-checkmate {
            0% { background-color: rgba(255, 0, 0, 0.7); }
            50% { background-color: rgba(255, 50, 50, 0.9); }
            100% { background-color: rgba(255, 0, 0, 0.7); }
        }
        
        .floating-piece {
            position: absolute;
            font-size: 40px;
            z-index: 100;
            pointer-events: none;
            animation: float 8s ease-in-out infinite;
        }
        
        @keyframes float {
            0% { transform: translate(0, 0) rotate(0deg); }
            25% { transform: translate(20px, -20px) rotate(5deg); }
            50% { transform: translate(0, -40px) rotate(0deg); }
            75% { transform: translate(-20px, -20px) rotate(-5deg); }
            100% { transform: translate(0, 0) rotate(0deg); }
        }
        
        @media (max-width: 768px) {
            .game-container {
                flex-direction: column;
                align-items: center;
            }
            
            td {
                width: 40px;
                height: 40px;
                font-size: 30px;
            }
            
            .header h1 {
                font-size: 2.5rem;
            }
            
            .intro-text {
                font-size: 1.8rem;
            }
            
            .game-over h2 {
                font-size: 2.5rem;
            }
        }
    </style>
</head>
<body>
    <!-- Интро -->
    <div class="intro">
        <div class="intro-text">Сделано Димой, код писался 2 дня</div>
        <div class="joke-text">Роме нельзя)</div>
    </div>
    
    <!-- Экран завершения игры -->
    <div class="game-over">
        <h2 id="game-result">Шах и Мат!</h2>
        <p id="winner-text">Победа белых!</p>
        <button id="play-again"><i class="fas fa-redo"></i> Играть снова</button>
    </div>
    
    <!-- Декоративные плавающие фигуры -->
    <div class="floating-piece" style="top: 10%; left: 5%;">♔</div>
    <div class="floating-piece" style="top: 15%; right: 7%;">♛</div>
    <div class="floating-piece" style="bottom: 20%; left: 8%;">♞</div>
    <div class="floating-piece" style="bottom: 15%; right: 10%;">♝</div>
    
    <div class="container">
        <div class="header">
            <h1>Шах и Мат</h1>
        </div>
        
        <div class="game-container">
            <div class="chess-board">
                <table id="board"></table>
            </div>
            
            <div class="controls">
                <div class="status">
                    <i class="fas fa-chess-knight"></i> Ход: <span id="turn">Белые</span>
                    <span id="check-indicator"></span>
                </div>
                
                <div class="buttons">
                    <button id="new-game"><i class="fas fa-plus-circle"></i> Новая игра</button>
                </div>
            </div>
        </div>
    </div>

    <script>
        document.addEventListener('DOMContentLoaded', function() {
            const board = document.getElementById('board');
            const turnDisplay = document.getElementById('turn');
            const checkIndicator = document.getElementById('check-indicator');
            const newGameBtn = document.getElementById('new-game');
            const gameOverScreen = document.querySelector('.game-over');
            const gameResult = document.getElementById('game-result');
            const winnerText = document.getElementById('winner-text');
            const playAgainBtn = document.getElementById('play-again');
            const intro = document.querySelector('.intro');
            
            // Скрываем интро через 3 секунды
            setTimeout(() => {
                intro.classList.add('hidden');
            }, 3000);
            
            // Создаем звуковые эффекты
            const sounds = {
                move: new Audio("data:audio/wav;base64,UklGRnoGAABXQVZFZm10IBAAAAABAAEAQB8AAEAfAAABAAgAZGF0YQoGAACBhYyNkJKSk5SUlJWVlpeXmJmam5ydnp+goaKjpKWmp6ipqqusra6vsLGys7S1tre4ubq7vL2+v8DBwsPExcbHyMnKy8zNzs/Q0dLT1NXW19jZ2tvc3d7f4OHi4+Tl5ufo6err7O3u7/Dx8vP09fb3+Pn6+/z9/v8AAAD/AA=="),
                capture: new Audio("data:audio/wav;base64,UklGRpQFAABXQVZFZm10IBAAAAABAAEARKwAAIhYAQACABAAZGF0YXAFAACFjI2QkpKTlJSUlZWWl5eYmZqbnJ2en6ChoqOkpaanqKmqq6ytrq+wsbKztLW2t7i5uru8vb6/wMHCw8TFxsfIycrLzM3Oz9DR0tPU1dbX2Nna29zd3t/g4eLj5OXm5+jp6uvs7e7v8PHy8/T19vf4+fr7/P3+/wAAAQ=="),
                select: new Audio("data:audio/wav;base64,UklGRlwDAABXQVZFZm10IBAAAAABAAEARKwAAIhYAQACABAAZGF0YUgDAACFjI2QkpKTlJSUlZWWl5eYmZqbnJ2en6ChoqOkpaanqKmqq6ytrq+wsbKztLW2t7i5uru8vb6/wMHCw8TFxsfIycrLzM3Oz9DR0tPU1dbX2Nna29zd3t/g4eLj5OXm5+jp6uvs7e7v8PHy8/T19vf4+fr7/P3+/wAAAQ=="),
                check: new Audio("data:audio/wav;base64,UklGRpQFAABXQVZFZm10IBAAAAABAAEARKwAAIhYAQACABAAZGF0YXAFAACFjI2QkpKTlJSUlZWWl5eYmZqbnJ2en6ChoqOkpaanqKmqq6ytrq+wsbKztLW2t7i5uru8vb6/wMHCw8TFxsfIycrLzM3Oz9DR0tPU1dbX2Nna29zd3t/g4eLj5OXm5+jp6uvs7e7v8PHy8/T19vf4+fr7/P3+/wAAAQ=="),
                checkmate: new Audio("data:audio/wav;base64,UklGRpQFAABXQVZFZm10IBAAAAABAAEARKwAAIhYAQACABAAZGF0YXAFAACFjI2QkpKTlJSUlZWWl5eYmZqbnJ2en6ChoqOkpaanqKmqq6ytrq+wsbKztLW2t7i5uru8vb6/wMHCw8TFxsfIycrLzM3Oz9DR0tPU1dbX2Nna29zd3t/g4eLj5OXm5+jp6uvs7e7v8PHy8/T19vf4+fr7/P3+/wAAAQ==")
            };
            
            // Шахматные фигуры в Unicode
            const pieces = {
                'r': '♜', 'n': '♞', 'b': '♝', 'q': '♛', 'k': '♚', 'p': '♟',
                'R': '♖', 'N': '♘', 'B': '♗', 'Q': '♕', 'K': '♔', 'P': '♙'
            };
            
            // Начальная позиция
            const initialPosition = [
                ['r', 'n', 'b', 'q', 'k', 'b', 'n', 'r'],
                ['p', 'p', 'p', 'p', 'p', 'p', 'p', 'p'],
                ['', '', '', '', '', '', '', ''],
                ['', '', '', '', '', '', '', ''],
                ['', '', '', '', '', '', '', ''],
                ['', '', '', '', '', '', '', ''],
                ['P', 'P', 'P', 'P', 'P', 'P', 'P', 'P'],
                ['R', 'N', 'B', 'Q', 'K', 'B', 'N', 'R']
            ];
            
            let selectedPiece = null;
            let currentPosition = JSON.parse(JSON.stringify(initialPosition));
            let isWhiteTurn = true;
            let checkStatus = { isCheck: false, isCheckmate: false };
            
            // Создаем шахматную доску
            function createBoard() {
                board.innerHTML = '';
                
                for (let row = 0; row < 8; row++) {
                    const tr = document.createElement('tr');
                    for (let col = 0; col < 8; col++) {
                        const td = document.createElement('td');
                        td.dataset.row = row;
                        td.dataset.col = col;
                        
                        // Чередуем цвета клеток
                        if ((row + col) % 2 === 0) {
                            td.classList.add('white');
                        } else {
                            td.classList.add('black');
                        }
                        
                        // Добавляем обозначения по краям доски
                        if (row === 0 && col > 0) {
                            const notation = document.createElement('span');
                            notation.className = 'notation top-notation';
                            notation.textContent = String.fromCharCode(96 + col);
                            td.appendChild(notation);
                        }
                        
                        if (col === 0 && row < 7) {
                            const notation = document.createElement('span');
                            notation.className = 'notation bottom-notation';
                            notation.textContent = 8 - row;
                            td.appendChild(notation);
                        }
                        
                        // Добавляем фигуры
                        const piece = currentPosition[row][col];
                        if (piece) {
                            addPieceToCell(td, piece);
                        }
                        
                        td.addEventListener('click', handleCellClick);
                        tr.appendChild(td);
                    }
                    board.appendChild(tr);
                }
            }
            
            // Добавляем фигуру на клетку
            function addPieceToCell(cell, piece) {
                const pieceElement = document.createElement('span');
                pieceElement.textContent = pieces[piece];
                pieceElement.className = piece === piece.toUpperCase() ? 'white-piece' : 'black-piece';
                cell.appendChild(pieceElement);
            }
            
            // Обработка клика по клетке
            function handleCellClick(event) {
                if (checkStatus.isCheckmate) return;
                
                const cell = event.currentTarget;
                const row = parseInt(cell.dataset.row);
                const col = parseInt(cell.dataset.col);
                const piece = currentPosition[row][col];
                
                // Проверяем, чья очередь ходить
                if (piece && ((isWhiteTurn && piece === piece.toUpperCase()) || 
                    (!isWhiteTurn && piece === piece.toLowerCase()))) {
                    
                    // Выбираем фигуру
                    selectPiece(row, col, piece);
                    playSound('select');
                } 
                // Если выбрана фигура и клик на возможный ход
                else if (selectedPiece && cell.classList.contains('possible-move')) {
                    makeMove(selectedPiece.row, selectedPiece.col, row, col);
                } 
                // Если выбрана фигуру и клик на возможное взятие
                else if (selectedPiece && cell.classList.contains('possible-capture')) {
                    makeMove(selectedPiece.row, selectedPiece.col, row, col);
                }
            }
            
            // Выбор фигуры
            function selectPiece(row, col, piece) {
                clearSelection();
                selectedPiece = { row, col, piece };
                
                // Подсвечиваем выбранную фигуру
                const cell = getCell(row, col);
                cell.classList.add('selected');
                
                // Показываем возможные ходы
                showPossibleMoves(row, col, piece);
            }
            
            // Показать возможные ходы
            function showPossibleMoves(row, col, piece) {
                const pieceType = piece.toLowerCase();
                const possibleMoves = [];
                
                if (pieceType === 'p') { // Пешка
                    const direction = piece === piece.toUpperCase() ? -1 : 1;
                    
                    // Ход на одну клетку вперед
                    if (isValidSquare(row + direction, col) && !currentPosition[row + direction][col]) {
                        possibleMoves.push({row: row + direction, col, isCapture: false});
                    }
                    
                    // Ход на две клетки из начальной позиции
                    const startRow = piece === piece.toUpperCase() ? 6 : 1;
                    if (row === startRow && !currentPosition[row + direction][col] && !currentPosition[row + 2*direction][col]) {
                        possibleMoves.push({row: row + 2*direction, col, isCapture: false});
                    }
                    
                    // Взятие
                    for (let dc of [-1, 1]) {
                        if (isValidSquare(row + direction, col + dc)) {
                            const targetPiece = currentPosition[row + direction][col + dc];
                            if (targetPiece && !isSameColor(piece, targetPiece)) {
                                possibleMoves.push({row: row + direction, col: col + dc, isCapture: true});
                            }
                        }
                    }
                } else if (pieceType === 'r') { // Ладья
                    possibleMoves.push(...getStraightMoves(row, col, piece));
                } else if (pieceType === 'n') { // Конь
                    for (let dr of [-2, -1, 1, 2]) {
                        for (let dc of [-2, -1, 1, 2]) {
                            if (Math.abs(dr) !== Math.abs(dc) && isValidSquare(row + dr, col + dc)) {
                                const targetPiece = currentPosition[row + dr][col + dc];
                                if (!targetPiece || !isSameColor(piece, targetPiece)) {
                                    possibleMoves.push({row: row + dr, col: col + dc, isCapture: !!targetPiece});
                                }
                            }
                        }
                    }
                } else if (pieceType === 'b') { // Слон
                    possibleMoves.push(...getDiagonalMoves(row, col, piece));
                } else if (pieceType === 'q') { // Ферзь
                    possibleMoves.push(...getStraightMoves(row, col, piece));
                    possibleMoves.push(...getDiagonalMoves(row, col, piece));
                } else if (pieceType === 'k') { // Король
                    for (let dr of [-1, 0, 1]) {
                        for (let dc of [-1, 0, 1]) {
                            if ((dr !== 0 || dc !== 0) && isValidSquare(row + dr, col + dc)) {
                                const targetPiece = currentPosition[row + dr][col + dc];
                                if (!targetPiece || !isSameColor(piece, targetPiece)) {
                                    possibleMoves.push({row: row + dr, col: col + dc, isCapture: !!targetPiece});
                                }
                            }
                        }
                    }
                }
                
                // Фильтруем ходы, которые оставляют короля под шахом
                const validMoves = possibleMoves.filter(move => {
                    // Создаем временную позицию для проверки
                    const tempPosition = JSON.parse(JSON.stringify(currentPosition));
                    tempPosition[move.row][move.col] = piece;
                    tempPosition[row][col] = '';
                    
                    // Проверяем, остается ли король под шахом
                    return !isKingInCheck(tempPosition, isWhiteTurn);
                });
                
                // Показываем только валидные ходы
                validMoves.forEach(move => {
                    if (move.isCapture) {
                        markPossibleMove(move.row, move.col, true);
                    } else {
                        markPossibleMove(move.row, move.col, false);
                    }
                });
            }
            
            // Получить прямые ходы (ладья, ферзь)
            function getStraightMoves(row, col, piece) {
                const directions = [[-1, 0], [1, 0], [0, -1], [0, 1]];
                const moves = [];
                
                for (let [dr, dc] of directions) {
                    let r = row + dr;
                    let c = col + dc;
                    
                    while (isValidSquare(r, c)) {
                        const targetPiece = currentPosition[r][c];
                        if (!targetPiece) {
                            moves.push({row: r, col: c, isCapture: false});
                        } else {
                            if (!isSameColor(piece, targetPiece)) {
                                moves.push({row: r, col: c, isCapture: true});
                            }
                            break;
                        }
                        r += dr;
                        c += dc;
                    }
                }
                
                return moves;
            }
            
            // Получить диагональные ходы (слон, ферзь)
            function getDiagonalMoves(row, col, piece) {
                const directions = [[-1, -1], [-1, 1], [1, -1], [1, 1]];
                const moves = [];
                
                for (let [dr, dc] of directions) {
                    let r = row + dr;
                    let c = col + dc;
                    
                    while (isValidSquare(r, c)) {
                        const targetPiece = currentPosition[r][c];
                        if (!targetPiece) {
                            moves.push({row: r, col: c, isCapture: false});
                        } else {
                            if (!isSameColor(piece, targetPiece)) {
                                moves.push({row: r, col: c, isCapture: true});
                            }
                            break;
                        }
                        r += dr;
                        c += dc;
                    }
                }
                
                return moves;
            }
            
            // Пометить возможный ход
            function markPossibleMove(row, col, isCapture) {
                const cell = getCell(row, col);
                if (isCapture) {
                    cell.classList.add('possible-capture');
                } else {
                    cell.classList.add('possible-move');
                }
            }
            
            // Сделать ход с анимацией
            function makeMove(fromRow, fromCol, toRow, toCol) {
                const piece = currentPosition[fromRow][fromCol];
                const targetPiece = currentPosition[toRow][toCol];
                
                // Создаем элемент для анимации
                const fromCell = getCell(fromRow, fromCol);
                const toCell = getCell(toRow, toCol);
                
                // Создаем копию фигуры для анимации
                const movingPiece = document.createElement('span');
                movingPiece.textContent = pieces[piece];
                movingPiece.className = piece === piece.toUpperCase() ? 'white-piece moved-piece' : 'black-piece moved-piece';
                
                // Позиционируем
                const fromRect = fromCell.getBoundingClientRect();
                const boardRect = board.getBoundingClientRect();
                
                movingPiece.style.left = (fromRect.left - boardRect.left + fromRect.width/2) + 'px';
                movingPiece.style.top = (fromRect.top - boardRect.top + fromRect.height/2) + 'px';
                movingPiece.style.fontSize = '50px';
                
                board.appendChild(movingPiece);
                
                // Запускаем анимацию
                setTimeout(() => {
                    const toRect = toCell.getBoundingClientRect();
                    
                    movingPiece.style.transform = `translate(${toRect.left - fromRect.left}px, ${toRect.top - fromRect.top}px)`;
                    
                    // После завершения анимации обновляем доску
                    setTimeout(() => {
                        board.removeChild(movingPiece);
                        
                        // Обновляем состояние игры
                        currentPosition[fromRow][fromCol] = '';
                        currentPosition[toRow][toCol] = piece;
                        
                        // Воспроизводим звук
                        if (targetPiece) {
                            playSound('capture');
                        } else {
                            playSound('move');
                        }
                        
                        // Меняем очередь хода
                        isWhiteTurn = !isWhiteTurn;
                        turnDisplay.textContent = isWhiteTurn ? 'Белые' : 'Черные';
                        turnDisplay.style.color = isWhiteTurn ? '#fff' : '#2c3e50';
                        
                        // Проверяем шах и мат
                        checkGameStatus();
                        
                        // Обновляем доску
                        updateBoard();
                        clearSelection();
                    }, 400);
                }, 10);
            }
            
            // Проверить состояние игры (шах, мат)
            function checkGameStatus() {
                const isCheck = isKingInCheck(currentPosition, !isWhiteTurn);
                const isCheckmate = isCheck && !hasValidMoves(!isWhiteTurn);
                
                checkStatus = { isCheck, isCheckmate };
                
                // Обновляем индикатор шаха
                if (isCheck) {
                    playSound('check');
                    checkIndicator.textContent = isWhiteTurn ? 'Шах черным!' : 'Шах белым!';
                    
                    // Находим клетку с королем и подсвечиваем ее
                    const king = isWhiteTurn ? 'k' : 'K';
                    for (let row = 0; row < 8; row++) {
                        for (let col = 0; col < 8; col++) {
                            if (currentPosition[row][col] === king) {
                                const cell = getCell(row, col);
                                cell.classList.add(isCheckmate ? 'checkmate' : 'check');
                                break;
                            }
                        }
                    }
                    
                    if (isCheckmate) {
                        playSound('checkmate');
                        showGameOver(!isWhiteTurn);
                    }
                } else {
                    checkIndicator.textContent = '';
                }
            }
            
            // Проверить, находится ли король под шахом
            function isKingInCheck(position, isWhiteKing) {
                const king = isWhiteKing ? 'K' : 'k';
                let kingPos = null;
                
                // Находим позицию короля
                for (let row = 0; row < 8; row++) {
                    for (let col = 0; col < 8; col++) {
                        if (position[row][col] === king) {
                            kingPos = { row, col };
                            break;
                        }
                    }
                    if (kingPos) break;
                }
                
                if (!kingPos) return false;
                
                // Проверяем все фигуры противника
                for (let row = 0; row < 8; row++) {
                    for (let col = 0; col < 8; col++) {
                        const piece = position[row][col];
                        if (piece && ((isWhiteKing && piece === piece.toLowerCase()) || 
                                       (!isWhiteKing && piece === piece.toUpperCase()))) {
                            
                            // Проверяем, может ли фигура атаковать короля
                            if (canAttack(position, row, col, kingPos.row, kingPos.col)) {
                                return true;
                            }
                        }
                    }
                }
                
                return false;
            }
            
            // Проверить, может ли фигура атаковать указанную клетку
            function canAttack(position, fromRow, fromCol, toRow, toCol) {
                const piece = position[fromRow][fromCol];
                const pieceType = piece.toLowerCase();
                
                if (pieceType === 'p') { // Пешка
                    const direction = piece === piece.toUpperCase() ? -1 : 1;
                    return (Math.abs(fromCol - toCol) === 1 && 
                           fromRow + direction === toRow);
                } 
                else if (pieceType === 'r') { // Ладья
                    return canStraightAttack(position, fromRow, fromCol, toRow, toCol);
                } 
                else if (pieceType === 'n') { // Конь
                    const dr = Math.abs(fromRow - toRow);
                    const dc = Math.abs(fromCol - toCol);
                    return (dr === 2 && dc === 1) || (dr === 1 && dc === 2);
                } 
                else if (pieceType === 'b') { // Слон
                    return canDiagonalAttack(position, fromRow, fromCol, toRow, toCol);
                } 
                else if (pieceType === 'q') { // Ферзь
                    return canStraightAttack(position, fromRow, fromCol, toRow, toCol) || 
                           canDiagonalAttack(position, fromRow, fromCol, toRow, toCol);
                } 
                else if (pieceType === 'k') { // Король
                    const dr = Math.abs(fromRow - toRow);
                    const dc = Math.abs(fromCol - toCol);
                    return dr <= 1 && dc <= 1;
                }
                
                return false;
            }
            
            // Проверить прямую атаку (ладья, ферзь)
            function canStraightAttack(position, fromRow, fromCol, toRow, toCol) {
                if (fromRow !== toRow && fromCol !== toCol) return false;
                
                const rowStep = fromRow === toRow ? 0 : (fromRow < toRow ? 1 : -1);
                const colStep = fromCol === toCol ? 0 : (fromCol < toCol ? 1 : -1);
                
                let r = fromRow + rowStep;
                let c = fromCol + colStep;
                
                while (r !== toRow || c !== toCol) {
                    if (position[r][c] !== '') return false;
                    r += rowStep;
                    c += colStep;
                }
                
                return true;
            }
            
            // Проверить диагональную атаку (слон, ферзь)
            function canDiagonalAttack(position, fromRow, fromCol, toRow, toCol) {
                if (Math.abs(fromRow - toRow) !== Math.abs(fromCol - toCol)) return false;
                
                const rowStep = fromRow < toRow ? 1 : -1;
                const colStep = fromCol < toCol ? 1 : -1;
                
                let r = fromRow + rowStep;
                let c = fromCol + colStep;
                
                while (r !== toRow && c !== toCol) {
                    if (position[r][c] !== '') return false;
                    r += rowStep;
                    c += colStep;
                }
                
                return true;
            }
            
            // Проверить, есть ли у стороны допустимые ходы
            function hasValidMoves(isWhite) {
                for (let row = 0; row < 8; row++) {
                    for (let col = 0; col < 8; col++) {
                        const piece = currentPosition[row][col];
                        if (piece && ((isWhite && piece === piece.toUpperCase()) || 
                                     (!isWhite && piece === piece.toLowerCase()))) {
                            
                            // Получаем все возможные ходы для фигуры
                            const moves = [];
                            const pieceType = piece.toLowerCase();
                            
                            if (pieceType === 'p') {
                                const direction = piece === piece.toUpperCase() ? -1 : 1;
                                
                                // Ход на одну клетку вперед
                                if (isValidSquare(row + direction, col) && !currentPosition[row + direction][col]) {
                                    moves.push({row: row + direction, col, isCapture: false});
                                }
                                
                                // Ход на две клетки из начальной позиции
                                const startRow = piece === piece.toUpperCase() ? 6 : 1;
                                if (row === startRow && !currentPosition[row + direction][col] && !currentPosition[row + 2*direction][col]) {
                                    moves.push({row: row + 2*direction, col, isCapture: false});
                                }
                                
                                // Взятие
                                for (let dc of [-1, 1]) {
                                    if (isValidSquare(row + direction, col + dc)) {
                                        const targetPiece = currentPosition[row + direction][col + dc];
                                        if (targetPiece && !isSameColor(piece, targetPiece)) {
                                            moves.push({row: row + direction, col: col + dc, isCapture: true});
                                        }
                                    }
                                }
                            } else if (pieceType === 'r') {
                                moves.push(...getStraightMoves(row, col, piece));
                            } else if (pieceType === 'n') {
                                for (let dr of [-2, -1, 1, 2]) {
                                    for (let dc of [-2, -1, 1, 2]) {
                                        if (Math.abs(dr) !== Math.abs(dc) && isValidSquare(row + dr, col + dc)) {
                                            const targetPiece = currentPosition[row + dr][col + dc];
                                            if (!targetPiece || !isSameColor(piece, targetPiece)) {
                                                moves.push({row: row + dr, col: col + dc, isCapture: !!targetPiece});
                                            }
                                        }
                                    }
                                }
                            } else if (pieceType === 'b') {
                                moves.push(...getDiagonalMoves(row, col, piece));
                            } else if (pieceType === 'q') {
                                moves.push(...getStraightMoves(row, col, piece));
                                moves.push(...getDiagonalMoves(row, col, piece));
                            } else if (pieceType === 'k') {
                                for (let dr of [-1, 0, 1]) {
                                    for (let dc of [-1, 0, 1]) {
                                        if ((dr !== 0 || dc !== 0) && isValidSquare(row + dr, col + dc)) {
                                            const targetPiece = currentPosition[row + dr][col + dc];
                                            if (!targetPiece || !isSameColor(piece, targetPiece)) {
                                                moves.push({row: row + dr, col: col + dc, isCapture: !!targetPiece});
                                            }
                                        }
                                    }
                                }
                            }
                            
                            // Проверяем, есть ли хотя бы один допустимый ход
                            for (let move of moves) {
                                // Создаем временную позицию для проверки
                                const tempPosition = JSON.parse(JSON.stringify(currentPosition));
                                tempPosition[move.row][move.col] = piece;
                                tempPosition[row][col] = '';
                                
                                // Проверяем, уходит ли король из-под шаха
                                if (!isKingInCheck(tempPosition, isWhite)) {
                                    return true;
                                }
                            }
                        }
                    }
                }
                
                return false;
            }
            
            // Показать экран завершения игры
            function showGameOver(isWhiteWinner) {
                gameResult.textContent = 'Шах и Мат!';
                winnerText.textContent = isWhiteWinner ? 'Победа белых!' : 'Победа черных!';
                gameOverScreen.classList.add('active');
            }
            
            // Обновить доску
            function updateBoard() {
                for (let row = 0; row < 8; row++) {
                    for (let col = 0; col < 8; col++) {
                        const cell = getCell(row, col);
                        cell.innerHTML = '';
                        cell.className = (row + col) % 2 === 0 ? 'white' : 'black';
                        
                        // Восстанавливаем обозначения
                        if (row === 0 && col > 0) {
                            const notation = document.createElement('span');
                            notation.className = 'notation top-notation';
                            notation.textContent = String.fromCharCode(96 + col);
                            cell.appendChild(notation);
                        }
                        
                        if (col === 0 && row < 7) {
                            const notation = document.createElement('span');
                            notation.className = 'notation bottom-notation';
                            notation.textContent = 8 - row;
                            cell.appendChild(notation);
                        }
                        
                        // Обновляем фигуры
                        const piece = currentPosition[row][col];
                        if (piece) {
                            addPieceToCell(cell, piece);
                        }
                    }
                }
            }
            
            // Очистить выделение
            function clearSelection() {
                if (selectedPiece) {
                    const cell = getCell(selectedPiece.row, selectedPiece.col);
                    cell.classList.remove('selected');
                }
                
                // Убираем все возможные ходы
                document.querySelectorAll('.possible-move, .possible-capture').forEach(cell => {
                    cell.classList.remove('possible-move', 'possible-capture');
                });
                
                selectedPiece = null;
            }
            
            // Получить клетку по координатам
            function getCell(row, col) {
                return board.rows[row].cells[col];
            }
            
            // Проверить, находится ли клетка в пределах доски
            function isValidSquare(row, col) {
                return row >= 0 && row < 8 && col >= 0 && col < 8;
            }
            
            // Проверить, одного ли цвета фигуры
            function isSameColor(piece1, piece2) {
                return (piece1 === piece1.toUpperCase()) === (piece2 === piece2.toUpperCase());
            }
            
            // Воспроизвести звук
            function playSound(type) {
                if (sounds[type]) {
                    sounds[type].currentTime = 0;
                    sounds[type].play().catch(e => console.log("Звук не воспроизведён:", e));
                }
            }
            
            // Новая игра
            newGameBtn.addEventListener('click', function() {
                currentPosition = JSON.parse(JSON.stringify(initialPosition));
                isWhiteTurn = true;
                checkStatus = { isCheck: false, isCheckmate: false };
                turnDisplay.textContent = 'Белые';
                turnDisplay.style.color = '#fff';
                checkIndicator.textContent = '';
                gameOverScreen.classList.remove('active');
                updateBoard();
                clearSelection();
                playSound('select');
            });
            
            // Играть снова
            playAgainBtn.addEventListener('click', function() {
                currentPosition = JSON.parse(JSON.stringify(initialPosition));
                isWhiteTurn = true;
                checkStatus = { isCheck: false, isCheckmate: false };
                turnDisplay.textContent = 'Белые';
                turnDisplay.style.color = '#fff';
                checkIndicator.textContent = '';
                gameOverScreen.classList.remove('active');
                updateBoard();
                clearSelection();
                playSound('select');
            });
            
            // Инициализация игры
            createBoard();
        });
    </script>
</body>
</html>
